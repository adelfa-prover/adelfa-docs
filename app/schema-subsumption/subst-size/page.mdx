---
title: Substitution Size
description: Subsumption example
---

[<small>Schema Subsumption</small>](/schema-subsumption)

import { Tabs, Callout } from 'nextra/components';

# Substitution Size of $$\lambda$$-calculus Terms

Our usage of the transport rule in [term has size](/schema-subsumption/size)
motivated our usage of transport in a simple theorem. A solution without using
the transport rule was to reprove a routine lemma under a new context variable.
This worked well for our small example, but does not scale to larger
developments. We will continue our reasoning about the size of lambda calculus
terms, which is based on the same definition as the [term has
size](/schema-subsumption/size) example, reiterated here:

```math
|x| = 1 \qquad |\lambda x. e| = 1 + |e| \qquad |e_1\ e_2| = 1 + |e_1| + |e_2|
```

Our goal is to show that the size of a lambda term does not decrease after
substitution.

> _Theorem_: For any $$\lambda$$-calculus terms $$e$$ and $$e'$$, $$|e| \leq
> |\{e'/x\}e|$$.

To specify this statement in LF, we will extend the one specification presented
in [term has size](/schema-subsumption/size#nat-sig) to include rules for less
than or equal to. Our library of theorems will also be expanded to include
properties about less than or equal to.

```lf filename="nat.lf"
leq : {x1:nat}{x2:nat} type.
leq-z : {x:nat} leq z x.
leq-s : {x1:nat}{x2:nat}{D: leq x1 x2} leq (s x1) (s x2).
```

<details>
  <summary>Library theorems</summary>
```adelfa filename="nat.ath"
Theorem plus-s-rhs : forall N1 N2 N3 D1,
  {D1: plus N1 N2 N3} =>
  exists D2, {D2: plus N1 (s N2) (s N3)}.
induction on 1.
intros.
case H1.
apply IH to H5.
exists plus-s x1 (s N2) (s x3) D2. search.
exists plus-z (s N3). search.

Theorem ident-rhs : forall x1,
  {x1: nat} => exists D, {D: plus x1 z x1}.
induction on 1.
intros.
case H1 (keep).
apply IH to H2.
exists plus-s x z x D. search.
exists plus-z z. search.

Theorem plus-exist : forall N1 N2,
  {N1: nat} => {N2:nat} => exists N3 D, {D: plus N1 N2 N3}.
induction on 1.
intros.
case H1.
apply IH to H3 H2.
exists s N3.
exists plus-s x N2 N3 D.
search.
exists N2.
exists plus-z N2. search.

Theorem plus-comm : forall N1 N2 N3 D1,
  {D1: plus N1 N2 N3} =>
  exists D2, {D2: plus N2 N1 N3}.
induction on 1.
intros.
case H1.
apply IH to H5.
apply plus-s-rhs to H6.
exists D1. search.
apply ident-rhs to H2.
exists D. search.

Theorem leq-transitive : forall x1 x2 x3 D1 D2,
  {D1: leq x1 x2} => {D2: leq x2 x3} =>
  exists D3, {D3: leq x1 x3}.
induction on 1.
intros.
case H1.
case H2.
apply IH to H5 H8.
exists leq-s x4 x7 D3.
search.
case H2.
exists leq-z (s x5).
search.
exists leq-z x3.
search.

Theorem leq-monotonic-plus-r : forall x1 x2 x3 x12 x13 D1 D2 D3,
  {D2: plus x1 x2 x12} => {D1: leq x2 x3} =>
  {D3: plus x1 x3 x13} =>
  exists D4, {D4: leq x12 x13}.
induction on 1.
intros.
case H1.
case H3.
apply IH to H7 H2 H11.
exists leq-s x6 x8 D2.
search.
case H3.
exists D1.
search.

Theorem leq-monotonic-plus-l : forall x1 x2 x3 x13 x23 D1 D2 D3,
  {D1: leq x1 x2} => {D2: plus x1 x3 x13} => {D3: plus x2 x3 x23} =>
  exists D4, {D4: leq x13 x23}.
intros.
apply plus-comm to H2.
apply plus-comm to H3.
apply leq-monotonic-plus-r to H4 H1 H5.
exists D6.
search.

Theorem leq-monotonic-plus : forall x1 x2 x3 x4 x13 x24 D1 D2 D3 D4,
  {D1: leq x1 x2} => {D2: leq x3 x4} =>
  {D3: plus x1 x3 x13} => { D4: plus x2 x4 x24} =>
  exists D6, {D6: leq x13 x24}.
intros.
assert { x2 : nat }.
assert { x3 : nat }.
apply plus-exist to H5 H6.
apply leq-monotonic-plus-l to H1 H3 H7.
apply leq-monotonic-plus-r to H7 H2 H4.
apply leq-transitive to H8 H9.
exists D7.
search.
```
</details>

Our informal theorem and proof is as follows, which implicitly utilizes several properties
about less than or equal to.

> _Proof_: By induction on the structure of $$e$$ followed by case analysis on $$e$$.
> 
> - If $$e$$ is a variable $$y$$:
>   - If $$x = y$$, $$|x| = 1$$, $$|\{e'/x\}x| = |e'|$$, by a routine
>      lemma, the size of a term must be at least one.[^1]
>   - If $$x \ne y$$, then this follows since $$\{e'/x\}y = y$$ and $$\leq$$ is
>      a reflexive relation.
> - If $$e$$ is an application, then $$|(e_1\ e_2)| = 1 + n_1 + n_2$$ by
>   definition. By application of the inductive hypothesis on the component
>   terms, there is some $$n'_1$$ and $$n'_2$$ such that $$|\{e'/x\}e_1| =
>   n'_1$$, $$|\{e'/x\}e_2| = n'_2$$, $$n_1 \leq n'_1$$ and $$n_2 \leq n'_2$$
>   hold. Addition is monotonic with respect to $$\leq$$, so $$n_1 + n_2 \leq n'_1 + n'_2$$.
>   Then $$1 + n_1 + n_2 \leq 1 + n'_1 + n'_2$$ follows.
> - If $$e$$ is an abstraction, $$|\lambda y. e| = 1 + n$$ such that $$y$$ does
>   not occur freely within $$e$$, then this follows inductive hypothesis with
>   $$e$$.
> 
> Q.E.D

[^1]: The proof of this follows by observing all judgements for size have an
    occurrence of 1 directly or 1 as the component of an addition.


Like our last theorem statement about $$\lambda$$-calculus terms have a size, we
will need to modify our theorem statement to be within a context. We can reuse
the same shape for the context here:

```adelfa filename="subst-size.ath"
Schema C := (x: tm, y: size x (s z)).
```

For pedagogical purposes, we present two ways of proving this statement. We will
strategically choose our theorem statement(s) in order to complete or simplify
the proof.

1. Immediately proved without context dependency
   ```adelfa filename="subst-size.ath"
   Theorem size-subst : ctx G:C, forall E' E: o -> o T-size D1: o -> o -> o,
     {G |- [x][dx] D1 x dx: {x:tm}{dx: size x (s z)} size (E x) T-size} =>
     {G |- E' : tm} =>
     exists D2 Sub-size D3, {G |- D2 : size (E E') Sub-size} /\
     {D3: leq T-size Sub-size}.
   ```
2. Proved with context dependency, then shown to be independent
   ```adelfa filename="subst-size.ath"
   Theorem size-subst' : ctx G:C, forall E' E: o -> o T-size D1: o -> o -> o,
     {G |- [x][dx] D1 x dx: {x:tm}{dx: size x (s z)} size (E x) T-size} =>
     {G |- E' : tm} =>
     exists D2 Sub-size D3, {G |- D2 : size (E E') Sub-size} /\
     {G |- D3: leq T-size Sub-size}.

   Theorem size-subst : ctx G:C, forall E' E: o -> o T-size D1: o -> o -> o,
     {G |- [x][dx] D1 x dx: {x:tm}{dx: size x (s z)} size (E x) T-size} =>
     {G |- E' : tm} =>
     exists D2 Sub-size D3, {G |- D2 : size (E E') Sub-size} /\
     {D3: leq T-size Sub-size}.
   ```

## Proof Without Transport

In this section, we will discuss a "hybrid" approach which utilizes both work in
our previous example since we needed the result of the lemma application to be
under a context variable. In our first theorem statement of `size-subst`, we do
not have the same problem. The issue presented with the size of an application
still arises, but we can reprove one lemma in order to complete that case. This,
in conjunction with independence lemmas for natural numbers, addition, and less
than or equal to, allows us to complete the proof.

```adelfa filename="subst-size.ath" execute
Theorem nat-independent : ctx G:C, forall N,
  {G |- N : nat } => {N : nat}.
induction on 1. intros. case H1.
apply IH to H2. search. search.

Theorem plus-independent : ctx G:C, forall N1 N2 N3 D,
  {G |- D : plus N1 N2 N3} => {D : plus N1 N2 N3}.
induction on 1. intros. case H1.
apply IH to H5. search. apply nat-independent to H2. search.

Theorem leq-independent : ctx G:C, forall N1 N2 D,
  {G |- D : leq N1 N2} => {D : leq N1 N2}.
induction on 1. intros. case H1.
apply IH to H4. apply nat-independent to H2.
apply nat-independent to H3. search.
apply nat-independent to H2. search.

% Reprove `plus-exist` but with context shape `C`
Theorem plus-exist-ind : ctx G:C, forall N1 N2,
  {G |- N1: nat} => {G |- N2:nat} => exists N3 D, {G |- D: plus N1 N2 N3}.
induction on 1.
intros.
case H1.
apply IH to H3 H2.
exists s N3.
exists plus-s x N2 N3 D.
search.
exists N2.
exists plus-z N2. search.

%{

>> Theorem nat-independent : ctx G:C, forall N,
  {G |- N : nat } => {N : nat}.

Subgoal nat-independent:


==================================
ctx G:C, forall N, {G |- N : nat} => {N : nat}

nat-independent>> induction on 1.

Subgoal nat-independent:

IH:ctx G:C, forall N, {G |- N : nat}* => {N : nat}

==================================
ctx G:C, forall N, {G |- N : nat}@ => {N : nat}

nat-independent>> intros.

Subgoal nat-independent:

Vars: N:o
Contexts: G{}:C[]
IH:ctx G:C, forall N, {G |- N : nat}* => {N : nat}
H1:{G |- N : nat}@

==================================
{N : nat}

nat-independent>> case H1.

Subgoal nat-independent.1:

Vars: x:o
Contexts: G{}:C[]
IH:ctx G:C, forall N, {G |- N : nat}* => {N : nat}
H2:{G |- x : nat}*

==================================
{s x : nat}

Subgoal nat-independent.2 is:
 {z : nat}

nat-independent.1>> apply IH to H2.

Subgoal nat-independent.1:

Vars: x:o
Contexts: G{}:C[]
IH:ctx G:C, forall N, {G |- N : nat}* => {N : nat}
H2:{G |- x : nat}*
H3:{x : nat}

==================================
{s x : nat}

Subgoal nat-independent.2 is:
 {z : nat}

nat-independent.1>> search.

Subgoal nat-independent.2:

Contexts: G{}:C[]
IH:ctx G:C, forall N, {G |- N : nat}* => {N : nat}

==================================
{z : nat}

nat-independent.2>> search.
Proof Completed!

>> Theorem plus-independent : ctx G:C, forall N1 N2 N3 D,
  {G |- D : plus N1 N2 N3} => {D : plus N1 N2 N3}.

Subgoal plus-independent:


==================================
ctx G:C,
  forall N1, forall N2, forall N3, forall D,
    {G |- D : plus N1 N2 N3} => {D : plus N1 N2 N3}

plus-independent>> induction on 1.

Subgoal plus-independent:

IH:
    ctx G:C,
      forall N1, forall N2, forall N3, forall D,
        {G |- D : plus N1 N2 N3}* => {D : plus N1 N2 N3}

==================================
ctx G:C,
  forall N1, forall N2, forall N3, forall D,
    {G |- D : plus N1 N2 N3}@ => {D : plus N1 N2 N3}

plus-independent>> intros.

Subgoal plus-independent:

Vars: D:o, N3:o, N2:o, N1:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall N3, forall D,
        {G |- D : plus N1 N2 N3}* => {D : plus N1 N2 N3}
H1:{G |- D : plus N1 N2 N3}@

==================================
{D : plus N1 N2 N3}

plus-independent>> case H1.

Subgoal plus-independent.1:

Vars: D1:o, x1:o, x3:o, N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall N3, forall D,
        {G |- D : plus N1 N2 N3}* => {D : plus N1 N2 N3}
H2:{G |- x1 : nat}*
H3:{G |- N2 : nat}*
H4:{G |- x3 : nat}*
H5:{G |- D1 : plus x1 N2 x3}*

==================================
{plus-s x1 N2 x3 D1 : plus (s x1) N2 (s x3)}

Subgoal plus-independent.2 is:
 {plus-z N3 : plus z N3 N3}

plus-independent.1>> apply IH to H5.

Subgoal plus-independent.1:

Vars: D1:o, x1:o, x3:o, N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall N3, forall D,
        {G |- D : plus N1 N2 N3}* => {D : plus N1 N2 N3}
H2:{G |- x1 : nat}*
H3:{G |- N2 : nat}*
H4:{G |- x3 : nat}*
H5:{G |- D1 : plus x1 N2 x3}*
H6:{D1 : plus x1 N2 x3}

==================================
{plus-s x1 N2 x3 D1 : plus (s x1) N2 (s x3)}

Subgoal plus-independent.2 is:
 {plus-z N3 : plus z N3 N3}

plus-independent.1>> search.

Subgoal plus-independent.2:

Vars: N3:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall N3, forall D,
        {G |- D : plus N1 N2 N3}* => {D : plus N1 N2 N3}
H2:{G |- N3 : nat}*

==================================
{plus-z N3 : plus z N3 N3}

plus-independent.2>> apply nat-independent to H2.

Subgoal plus-independent.2:

Vars: N3:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall N3, forall D,
        {G |- D : plus N1 N2 N3}* => {D : plus N1 N2 N3}
H2:{G |- N3 : nat}*
H3:{N3 : nat}

==================================
{plus-z N3 : plus z N3 N3}

plus-independent.2>> search.
Proof Completed!

>> Theorem leq-independent : ctx G:C, forall N1 N2 D,
  {G |- D : leq N1 N2} => {D : leq N1 N2}.

Subgoal leq-independent:


==================================
ctx G:C,
  forall N1, forall N2, forall D, {G |- D : leq N1 N2} => {D : leq N1 N2}

leq-independent>> induction on 1.

Subgoal leq-independent:

IH:
    ctx G:C,
      forall N1, forall N2, forall D,
        {G |- D : leq N1 N2}* => {D : leq N1 N2}

==================================
ctx G:C,
  forall N1, forall N2, forall D, {G |- D : leq N1 N2}@ => {D : leq N1 N2}

leq-independent>> intros.

Subgoal leq-independent:

Vars: D:o, N2:o, N1:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall D,
        {G |- D : leq N1 N2}* => {D : leq N1 N2}
H1:{G |- D : leq N1 N2}@

==================================
{D : leq N1 N2}

leq-independent>> case H1.

Subgoal leq-independent.1:

Vars: d:o, x1:o, x2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall D,
        {G |- D : leq N1 N2}* => {D : leq N1 N2}
H2:{G |- x1 : nat}*
H3:{G |- x2 : nat}*
H4:{G |- d : leq x1 x2}*

==================================
{leq-s x1 x2 d : leq (s x1) (s x2)}

Subgoal leq-independent.2 is:
 {leq-z N2 : leq z N2}

leq-independent.1>> apply IH to H4.

Subgoal leq-independent.1:

Vars: d:o, x1:o, x2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall D,
        {G |- D : leq N1 N2}* => {D : leq N1 N2}
H2:{G |- x1 : nat}*
H3:{G |- x2 : nat}*
H4:{G |- d : leq x1 x2}*
H5:{d : leq x1 x2}

==================================
{leq-s x1 x2 d : leq (s x1) (s x2)}

Subgoal leq-independent.2 is:
 {leq-z N2 : leq z N2}

leq-independent.1>> apply nat-independent to H2.

Subgoal leq-independent.1:

Vars: d:o, x1:o, x2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall D,
        {G |- D : leq N1 N2}* => {D : leq N1 N2}
H2:{G |- x1 : nat}*
H3:{G |- x2 : nat}*
H4:{G |- d : leq x1 x2}*
H5:{d : leq x1 x2}
H6:{x1 : nat}

==================================
{leq-s x1 x2 d : leq (s x1) (s x2)}

Subgoal leq-independent.2 is:
 {leq-z N2 : leq z N2}

leq-independent.1>> apply nat-independent to H3.

Subgoal leq-independent.1:

Vars: d:o, x1:o, x2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall D,
        {G |- D : leq N1 N2}* => {D : leq N1 N2}
H2:{G |- x1 : nat}*
H3:{G |- x2 : nat}*
H4:{G |- d : leq x1 x2}*
H5:{d : leq x1 x2}
H6:{x1 : nat}
H7:{x2 : nat}

==================================
{leq-s x1 x2 d : leq (s x1) (s x2)}

Subgoal leq-independent.2 is:
 {leq-z N2 : leq z N2}

leq-independent.1>> search.

Subgoal leq-independent.2:

Vars: N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall D,
        {G |- D : leq N1 N2}* => {D : leq N1 N2}
H2:{G |- N2 : nat}*

==================================
{leq-z N2 : leq z N2}

leq-independent.2>> apply nat-independent to H2.

Subgoal leq-independent.2:

Vars: N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2, forall D,
        {G |- D : leq N1 N2}* => {D : leq N1 N2}
H2:{G |- N2 : nat}*
H3:{N2 : nat}

==================================
{leq-z N2 : leq z N2}

leq-independent.2>> search.
Proof Completed!

>> Theorem plus-exist-ind : ctx G:C, forall N1 N2,
  {G |- N1: nat} => {G |- N2:nat} => exists N3 D, {G |- D: plus N1 N2 N3}.

Subgoal plus-exist-ind:


==================================
ctx G:C,
  forall N1, forall N2,
    {G |- N1 : nat} =>
        {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}

plus-exist-ind>> induction on 1.

Subgoal plus-exist-ind:

IH:
    ctx G:C,
      forall N1, forall N2,
        {G |- N1 : nat}* =>
            {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}

==================================
ctx G:C,
  forall N1, forall N2,
    {G |- N1 : nat}@ =>
        {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}

plus-exist-ind>> intros.

Subgoal plus-exist-ind:

Vars: N2:o, N1:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2,
        {G |- N1 : nat}* =>
            {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}
H1:{G |- N1 : nat}@
H2:{G |- N2 : nat}

==================================
exists N3, exists D, {G |- D : plus N1 N2 N3}

plus-exist-ind>> case H1.

Subgoal plus-exist-ind.1:

Vars: x:o, N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2,
        {G |- N1 : nat}* =>
            {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}
H2:{G |- N2 : nat}
H3:{G |- x : nat}*

==================================
exists N3, exists D, {G |- D : plus (s x) N2 N3}

Subgoal plus-exist-ind.2 is:
 exists N3, exists D, {G |- D : plus z N2 N3}

plus-exist-ind.1>> apply IH to H3 H2.

Subgoal plus-exist-ind.1:

Vars: D:o, N3:o, x:o, N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2,
        {G |- N1 : nat}* =>
            {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}
H2:{G |- N2 : nat}
H3:{G |- x : nat}*
H4:{G |- D : plus x N2 N3}

==================================
exists N3, exists D, {G |- D : plus (s x) N2 N3}

Subgoal plus-exist-ind.2 is:
 exists N3, exists D, {G |- D : plus z N2 N3}

plus-exist-ind.1>> exists s N3.

Subgoal plus-exist-ind.1:

Vars: D:o, N3:o, x:o, N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2,
        {G |- N1 : nat}* =>
            {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}
H2:{G |- N2 : nat}
H3:{G |- x : nat}*
H4:{G |- D : plus x N2 N3}

==================================
exists D, {G |- D : plus (s x) N2 (s N3)}

Subgoal plus-exist-ind.2 is:
 exists N3, exists D, {G |- D : plus z N2 N3}

plus-exist-ind.1>> exists plus-s x N2 N3 D.

Subgoal plus-exist-ind.1:

Vars: D:o, N3:o, x:o, N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2,
        {G |- N1 : nat}* =>
            {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}
H2:{G |- N2 : nat}
H3:{G |- x : nat}*
H4:{G |- D : plus x N2 N3}

==================================
{G |- plus-s x N2 N3 D : plus (s x) N2 (s N3)}

Subgoal plus-exist-ind.2 is:
 exists N3, exists D, {G |- D : plus z N2 N3}

plus-exist-ind.1>> search.

Subgoal plus-exist-ind.2:

Vars: N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2,
        {G |- N1 : nat}* =>
            {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}
H2:{G |- N2 : nat}

==================================
exists N3, exists D, {G |- D : plus z N2 N3}

plus-exist-ind.2>> exists N2.

Subgoal plus-exist-ind.2:

Vars: N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2,
        {G |- N1 : nat}* =>
            {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}
H2:{G |- N2 : nat}

==================================
exists D, {G |- D : plus z N2 N2}

plus-exist-ind.2>> exists plus-z N2.

Subgoal plus-exist-ind.2:

Vars: N2:o
Contexts: G{}:C[]
IH:
    ctx G:C,
      forall N1, forall N2,
        {G |- N1 : nat}* =>
            {G |- N2 : nat} => exists N3, exists D, {G |- D : plus N1 N2 N3}
H2:{G |- N2 : nat}

==================================
{G |- plus-z N2 : plus z N2 N2}

plus-exist-ind.2>> search.
Proof Completed!
}%
```


We'll now walk through the proof, and show the general pattern one must use to
properly utilize these proofs. Starting with the application case, we follow our 
informal proof by applying the inductive hypothesis to the component terms.


```adelfa filename="subst-size.ath" execute
Theorem size-subst : ctx G:C, forall E' E: o -> o T-size D1: o -> o -> o,
  {G |- [x][dx] D1 x dx: {x:tm}{dx: size x (s z)} size (E x) T-size} =>
  {G |- E' : tm} =>
    exists D2 Sub-size D3,
      {G |- D2 : size (E E') Sub-size} /\
      {D3: leq T-size Sub-size}.
induction on 1.
intros.
case H1.
% app case
  prune H6. prune H5. prune H10.
  apply IH to H8 H2. apply IH to H9 H2.
  case H11. prune H13. prune H14.
  case H12. prune H15. prune H16.

%{

>> Theorem size-subst : ctx G:C, forall E' E: o -> o T-size D1: o -> o -> o,
  {G |- [x][dx] D1 x dx: {x:tm}{dx: size x (s z)} size (E x) T-size} =>
  {G |- E' : tm} =>
    exists D2 Sub-size D3,
      {G |- D2 : size (E E') Sub-size} /\
      {D3: leq T-size Sub-size}.

Subgoal size-subst:


==================================
ctx G:C,
  forall E', forall E, forall T-size, forall D1,
    {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size} =>
        {G |- E' : tm} =>
            exists D2, exists Sub-size, exists D3,
              {G |- D2 : size (E E') Sub-size} /\ {D3 : leq T-size Sub-size}

size-subst>> induction on 1.

Subgoal size-subst:

IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}

==================================
ctx G:C,
  forall E', forall E, forall T-size, forall D1,
    {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}@ =>
        {G |- E' : tm} =>
            exists D2, exists Sub-size, exists D3,
              {G |- D2 : size (E E') Sub-size} /\ {D3 : leq T-size Sub-size}

size-subst>> intros.

Subgoal size-subst:

Vars: D1:(o) -> (o) -> o, T-size:o, E:(o) -> o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H1:{G, n:tm, n1:size n (s z) |- D1 n n1 : size (E n) T-size}@
H2:{G |- E' : tm}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (E E') Sub-size} /\ {D3 : leq T-size Sub-size}

size-subst>> case H1.

Subgoal size-subst.1:

Vars: X1:(o) -> (o) -> o, X2:(o) -> (o) -> o, D2:(o) -> (o) -> o, D3:
        (o) -> (o) -> o, D4:(o) -> (o) -> o, E1:(o) -> o, E2:(o) -> o,
        T-size1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 n1 n : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 n1 n : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) (X1 n1 n)}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) (X2 n1 n)}*
H10:{G, n:tm, n1:size n (s z) |- D4 n1 n : plus (X1 n1 n) (X2 n1 n) T-size1}*

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H6.

Subgoal size-subst.1:

Vars: X1:(o) -> (o) -> o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:
        (o) -> (o) -> o, E1:(o) -> o, E2:(o) -> o, T-size1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 n1 n : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) (X1 n1 n)}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 n1 n : plus (X1 n1 n) X2 T-size1}*

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H5.

Subgoal size-subst.1:

Vars: X1:o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:(o) -> (o) -> o,
        E1:(o) -> o, E2:(o) -> o, T-size1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 n1 n : plus X1 X2 T-size1}*

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H10.

Subgoal size-subst.1:

Vars: X1:o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:(o) -> o,
        E2:(o) -> o, T-size1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> apply IH to H8 H2.

Subgoal size-subst.1:

Vars: D5:(o) -> (o) -> o, Sub-size:(o) -> (o) -> o, X1:o, X2:o, D2:
        (o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o,
        T-size1:o, D1:(o) -> (o) -> o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H11:
    {G |- D1 n1 n : size (E1 E') (Sub-size n1 n)} /\
        {D5 n1 n : leq X1 (Sub-size n1 n)}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> apply IH to H9 H2.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:(o) -> (o) -> o, D6:(o) -> (o) -> o, D5:
        (o) -> (o) -> o, Sub-size:(o) -> (o) -> o, X1:o, X2:o, D2:
        (o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o,
        T-size1:o, D1:(o) -> (o) -> o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H11:
    {G |- D1 n1 n : size (E1 E') (Sub-size n1 n)} /\
        {D5 n1 n : leq X1 (Sub-size n1 n)}
H12:
    {G |- D6 n1 n : size (E2 E') (Sub-size1 n1 n)} /\
        {D7 n1 n : leq X2 (Sub-size1 n1 n)}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> case H11.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:(o) -> (o) -> o, D6:(o) -> (o) -> o, D5:
        (o) -> (o) -> o, Sub-size:(o) -> (o) -> o, X1:o, X2:o, D2:
        (o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o,
        T-size1:o, D1:(o) -> (o) -> o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H12:
    {G |- D6 n1 n : size (E2 E') (Sub-size1 n1 n)} /\
        {D7 n1 n : leq X2 (Sub-size1 n1 n)}
H13:{G |- D1 n1 n : size (E1 E') (Sub-size n1 n)}
H14:{D5 n1 n : leq X1 (Sub-size n1 n)}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H13.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:(o) -> (o) -> o, D6:(o) -> (o) -> o, D5:
        (o) -> (o) -> o, Sub-size:(o) -> (o) -> o, X1:o, X2:o, D2:
        (o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o,
        T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H12:
    {G |- D6 n1 n : size (E2 E') (Sub-size1 n1 n)} /\
        {D7 n1 n : leq X2 (Sub-size1 n1 n)}
H13:{G |- D1 : size (E1 E') (Sub-size n1 n)}
H14:{D5 n1 n : leq X1 (Sub-size n1 n)}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H14.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:(o) -> (o) -> o, D6:(o) -> (o) -> o, D5:
        (o) -> (o) -> o, Sub-size:(o) -> (o) -> o, X1:o, X2:o, D2:
        (o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o,
        T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H12:
    {G |- D6 n1 n : size (E2 E') (Sub-size1 n1 n)} /\
        {D7 n1 n : leq X2 (Sub-size1 n1 n)}
H13:{G |- D1 : size (E1 E') (Sub-size n1 n)}
H14:{D5 n1 n : leq X1 (Sub-size n1 n)}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> case H12.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:(o) -> (o) -> o, D6:(o) -> (o) -> o, D5:
        (o) -> (o) -> o, Sub-size:(o) -> (o) -> o, X1:o, X2:o, D2:
        (o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o,
        T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') (Sub-size n1 n)}
H14:{D5 n1 n : leq X1 (Sub-size n1 n)}
H15:{G |- D6 n1 n : size (E2 E') (Sub-size1 n1 n)}
H16:{D7 n1 n : leq X2 (Sub-size1 n1 n)}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H15.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:(o) -> (o) -> o, D6:o, D5:
        (o) -> (o) -> o, Sub-size:(o) -> (o) -> o, X1:o, X2:o, D2:
        (o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o,
        T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') (Sub-size n1 n)}
H14:{D5 n1 n : leq X1 (Sub-size n1 n)}
H15:{G |- D6 : size (E2 E') (Sub-size1 n1 n)}
H16:{D7 n1 n : leq X2 (Sub-size1 n1 n)}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H16.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:(o) -> (o) -> o, D6:o, D5:
        (o) -> (o) -> o, Sub-size:(o) -> (o) -> o, X1:o, X2:o, D2:
        (o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o,
        T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') (Sub-size n1 n)}
H14:{D5 n1 n : leq X1 (Sub-size n1 n)}
H15:{G |- D6 : size (E2 E') (Sub-size1 n1 n)}
H16:{D7 n1 n : leq X2 (Sub-size1 n1 n)}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}
}%
```

Let us first try to get the total size of the application, to instantiate the
`Sub-size` variable in our consequent. We will utilize our lifted version of
`plus-exist` with `Sub-size` and `Sub-size1` to accomplish this. We have to do
some intermediate assertions to get assumption formulas for the natural
numbers, then invoke our `plus-exist'`.


```adelfa filename="subst-size" execute
assert {G |- Sub-size n1 n : nat}. prune H17.
assert {G |- Sub-size1 n1 n : nat}. prune H18.
apply plus-exist' to H17 H18. prune H19.

%{

size-subst.1>> assert {G |- Sub-size n1 n : nat}.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:(o) -> (o) -> o, D6:o, D5:
        (o) -> (o) -> o, Sub-size:(o) -> (o) -> o, X1:o, X2:o, D2:
        (o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o,
        T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') (Sub-size n1 n)}
H14:{D5 n1 n : leq X1 (Sub-size n1 n)}
H15:{G |- D6 : size (E2 E') (Sub-size1 n1 n)}
H16:{D7 n1 n : leq X2 (Sub-size1 n1 n)}
H17:{G |- Sub-size n1 n : nat}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H17.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:(o) -> (o) -> o, D6:o, D5:
        (o) -> (o) -> o, Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:
        (o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':
        o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') (Sub-size1 n1 n)}
H16:{D7 n1 n : leq X2 (Sub-size1 n1 n)}
H17:{G |- Sub-size : nat}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> assert {G |- Sub-size1 n1 n : nat}.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:(o) -> (o) -> o, D6:o, D5:
        (o) -> (o) -> o, Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:
        (o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':
        o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') (Sub-size1 n1 n)}
H16:{D7 n1 n : leq X2 (Sub-size1 n1 n)}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 n1 n : nat}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H18.

Subgoal size-subst.1:

Vars: D7:(o) -> (o) -> o, Sub-size1:o, D6:o, D5:(o) -> (o) -> o, Sub-size:o,
        X1:o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o, E1:
        (o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> apply plus-exist' to H17 H18.

Subgoal size-subst.1:

Vars: D:(o) -> (o) -> o, N3:(o) -> (o) -> o, D7:(o) -> (o) -> o, Sub-size1:o,
        D6:o, D5:(o) -> (o) -> o, Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o,
        D3:(o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o,
        E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D n1 n : plus Sub-size Sub-size1 (N3 n1 n)}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H19.

Subgoal size-subst.1:

Vars: D:o, N3:(o) -> (o) -> o, D7:(o) -> (o) -> o, Sub-size1:o, D6:o, D5:
        (o) -> (o) -> o, Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:
        (o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':
        o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D : plus Sub-size Sub-size1 (N3 n1 n)}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}
}%
```

The next step is to ensure that the substitution size is less than the term's
size prior to substitution. This will require the monotonicity property for
addition with respect to less than or equal to. This property being in the empty
context will require us to apply our independence lemmas.

```adelfa filename="subst-size" execute
assert { G |- N3 n1 n : nat }. prune H20.
assert { G |- D4 : plus X1 X2 T-size1 }*. strengthen H10. strengthen H21. search.
apply plus-independent to H21. apply plus-independent to H19.
apply leq-monotonic-plus to H14 H16 H22 H23.

%{

size-subst.1>> assert { G |- N3 n1 n : nat }.

Subgoal size-subst.1:

Vars: D:o, N3:(o) -> (o) -> o, D7:(o) -> (o) -> o, Sub-size1:o, D6:o, D5:
        (o) -> (o) -> o, Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:
        (o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':
        o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D : plus Sub-size Sub-size1 (N3 n1 n)}
H20:{G |- N3 n1 n : nat}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> prune H20.

Subgoal size-subst.1:

Vars: D:o, N3:o, D7:(o) -> (o) -> o, Sub-size1:o, D6:o, D5:(o) -> (o) -> o,
        Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o,
        E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D : plus Sub-size Sub-size1 N3}
H20:{G |- N3 : nat}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> assert { G |- D4 : plus X1 X2 T-size1 }*.

Subgoal size-subst.1:

Vars: D:o, N3:o, D7:(o) -> (o) -> o, Sub-size1:o, D6:o, D5:(o) -> (o) -> o,
        Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o,
        E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D : plus Sub-size Sub-size1 N3}
H20:{G |- N3 : nat}

==================================
{G |- D4 : plus X1 X2 T-size1}*

Subgoal size-subst.1 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> strengthen H10.

Subgoal size-subst.1:

Vars: D:o, N3:o, D7:(o) -> (o) -> o, Sub-size1:o, D6:o, D5:(o) -> (o) -> o,
        Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o,
        E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D : plus Sub-size Sub-size1 N3}
H20:{G |- N3 : nat}
H21:{G, n:tm |- D4 : plus X1 X2 T-size1}*

==================================
{G |- D4 : plus X1 X2 T-size1}*

Subgoal size-subst.1 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> strengthen H21.

Subgoal size-subst.1:

Vars: D:o, N3:o, D7:(o) -> (o) -> o, Sub-size1:o, D6:o, D5:(o) -> (o) -> o,
        Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o,
        E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D : plus Sub-size Sub-size1 N3}
H20:{G |- N3 : nat}
H21:{G, n:tm |- D4 : plus X1 X2 T-size1}*
H22:{G |- D4 : plus X1 X2 T-size1}*

==================================
{G |- D4 : plus X1 X2 T-size1}*

Subgoal size-subst.1 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> search.

Subgoal size-subst.1:

Vars: D:o, N3:o, D7:(o) -> (o) -> o, Sub-size1:o, D6:o, D5:(o) -> (o) -> o,
        Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o,
        E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D : plus Sub-size Sub-size1 N3}
H20:{G |- N3 : nat}
H21:{G |- D4 : plus X1 X2 T-size1}*

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> apply plus-independent to H21.

Subgoal size-subst.1:

Vars: D:o, N3:o, D7:(o) -> (o) -> o, Sub-size1:o, D6:o, D5:(o) -> (o) -> o,
        Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o,
        E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D : plus Sub-size Sub-size1 N3}
H20:{G |- N3 : nat}
H21:{G |- D4 : plus X1 X2 T-size1}*
H22:{D4 : plus X1 X2 T-size1}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> apply plus-independent to H19.

Subgoal size-subst.1:

Vars: D:o, N3:o, D7:(o) -> (o) -> o, Sub-size1:o, D6:o, D5:(o) -> (o) -> o,
        Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:(o) -> (o) -> o, D4:o,
        E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D : plus Sub-size Sub-size1 N3}
H20:{G |- N3 : nat}
H21:{G |- D4 : plus X1 X2 T-size1}*
H22:{D4 : plus X1 X2 T-size1}
H23:{D : plus Sub-size Sub-size1 N3}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}

size-subst.1>> apply leq-monotonic-plus to H14 H16 H22 H23.

Subgoal size-subst.1:

Vars: D8:(o) -> (o) -> o, D:o, N3:o, D7:(o) -> (o) -> o, Sub-size1:o, D6:o,
        D5:(o) -> (o) -> o, Sub-size:o, X1:o, X2:o, D2:(o) -> (o) -> o, D3:
        (o) -> (o) -> o, D4:o, E1:(o) -> o, E2:(o) -> o, T-size1:o, D1:o, E':
        o
Nominals: n1:o, n:o
Contexts: G{n, n1}:C[]
IH:
    ctx G:C,
      forall E', forall E, forall T-size, forall D1,
        {G |- [x][dx]D1 x dx : {x:tm}{dx:size x (s z)}size (E x) T-size}* =>
            {G |- E' : tm} =>
                exists D2, exists Sub-size, exists D3,
                  {G |- D2 : size (E E') Sub-size} /\
                      {D3 : leq T-size Sub-size}
H2:{G |- E' : tm}
H3:{G, n:tm, n1:size n (s z) |- E1 n : tm}*
H4:{G, n:tm, n1:size n (s z) |- E2 n : tm}*
H5:{G, n:tm, n1:size n (s z) |- X1 : nat}*
H6:{G, n:tm, n1:size n (s z) |- X2 : nat}*
H7:{G, n:tm, n1:size n (s z) |- T-size1 : nat}*
H8:{G, n:tm, n1:size n (s z) |- D2 n1 n : size (E1 n) X1}*
H9:{G, n:tm, n1:size n (s z) |- D3 n1 n : size (E2 n) X2}*
H10:{G, n:tm, n1:size n (s z) |- D4 : plus X1 X2 T-size1}*
H13:{G |- D1 : size (E1 E') Sub-size}
H14:{D5 n1 n : leq X1 Sub-size}
H15:{G |- D6 : size (E2 E') Sub-size1}
H16:{D7 n1 n : leq X2 Sub-size1}
H17:{G |- Sub-size : nat}
H18:{G |- Sub-size1 : nat}
H19:{G |- D : plus Sub-size Sub-size1 N3}
H20:{G |- N3 : nat}
H21:{G |- D4 : plus X1 X2 T-size1}*
H22:{D4 : plus X1 X2 T-size1}
H23:{D : plus Sub-size Sub-size1 N3}
H24:{D8 n1 n : leq T-size1 N3}

==================================
exists D2, exists Sub-size, exists D3,
  {G |- D2 : size (app (E1 E') (E2 E')) Sub-size} /\
      {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.2 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size (lam ([c50]E1 E' c50)) Sub-size} /\
       {D3 : leq (s T-size1) Sub-size}

Subgoal size-subst.3 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size empty Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.4 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size E' Sub-size} /\ {D3 : leq (s z) Sub-size}

Subgoal size-subst.5 is:
 exists D2, exists Sub-size, exists D3,
   {G |- D2 : size n2 Sub-size} /\ {D3 : leq (s z) Sub-size}
}%
```

The remainder of the theorem follows a similar pattern. One will strengthen
the necessary assumptions then invoke the relevant lemma. We include the
proof in its entirety here:

```adelfa filename="subst-size.ath"
Theorem size-subst : ctx G:C, forall E' E: o -> o T-size D1: o -> o -> o,
  {G |- [x][dx] D1 x dx: {x:tm}{dx: size x (s z)} size (E x) T-size} =>
  {G |- E' : tm} =>
    exists D2 Sub-size D3,
      {G |- D2 : size (E E') Sub-size} /\
      {D3: leq T-size Sub-size}.
induction on 1.
intros.
case H1.
% app case
  prune H6. prune H5. prune H10.
  apply IH to H8 H2. apply IH to H9 H2.
  case H11. prune H13. prune H14.
  case H12. prune H15. prune H16.
  assert {G |- Sub-size n1 n : nat}. prune H17.
  assert {G |- Sub-size1 n1 n : nat}. prune H18.
  apply plus-exist' to H17 H18. prune H19.
  assert { G |- N3 n1 n : nat }. prune H20.
  assert { G |- D4 : plus X1 X2 T-size1 }*. strengthen H10. strengthen H21. search.
  apply plus-independent to H21. apply plus-independent to H19.
  apply leq-monotonic-plus to H14 H16 H22 H23.
  exists size-app (E1 E') (E2 E') Sub-size Sub-size1 N3 D1 D6 D.
  exists (s N3). exists leq-s T-size1 N3 (D8 n1 n). split. search. search.
% lam
  weaken H2 with tm. weaken H6 with size n5 (s z).
  ctxpermute H5 to G, n3:tm, n4: size n3 (s z), n:tm, n1:size n (s z).
  apply IH to H8 H7 with (G = G, n1:tm, n:size n1 (s z)).
  case H9.
  prune H10. prune H11.
  assert {G, n1:tm, n:size n1 (s z) |- Sub-size n6 n5 n4 n3 n2 n1 n : nat}. prune H12.
  inst H3 with n = E'. strengthen H13.
  ctxpermute H13 to G, n2:tm, n1: size E' (s z). strengthen H14.
  exists size-lam ([x] E1 E' x) Sub-size D2. exists (s Sub-size). strengthen H12. strengthen H16.
  exists leq-s T-size1 Sub-size (D3 n6 n5 n4 n3 n2 n1 n). split. search. search.
% var1
  apply tm-has-size to H2. prune H3. assert {G |- N n1 n : nat}. prune H4.
  exists D. exists N. apply size-at-least-one to H3. prune H5. 
  exists D' n1 n. split. search. search.
% var2
  exists n3. exists (s z). exists leq-s z z (leq-z z). split. search. search.
```

## Proof with Transport

Our proof with transport will utilize our second presentation of the theorem,
where we prove the property within the context and then later prove that the
desired judgements are independent of the context. This leads to a more
straightforward version of the proof, with no uses of independence lemmas in the
proof of `size-subst`. For example, the application case is:

```adelfa filename="subst-size.ath"
Theorem size-subst : ctx G:C, forall E' E: o -> o T-size D1: o -> o -> o,
  {G |- [x][dx] D1 x dx: {x:tm}{dx: size x (s z)} size (E x) T-size} =>
  {G |- E' : tm} =>
  exists D2 Sub-size D3, {G |- D2 : size (E E') Sub-size} /\
  {G |- D3: leq T-size Sub-size}.
induction on 1.
intros.
case H1 (keep).
% app case
  prune H6.
  prune H5.
  apply IH to H8 H2.
  apply IH to H9 H2.
  case H11. prune H13. prune H14.
  case H12. prune H15. prune H16.
  assert {G |- Sub-size n1 n : nat}. prune H17.
  assert {G |- Sub-size1 n1 n : nat}. prune H18.
  apply plus-exist to H17 H18. prune H19.
  assert { G |- N3 n1 n : nat }. prune H20.
  prune H10. assert { G |- D4 : plus X1 X2 T-size1 }*. strengthen H10. strengthen H21. search.
  apply leq-monotonic-plus to H14 H16 H21 H19. prune H22.
  exists size-app (E1 E') (E2 E') Sub-size Sub-size1 N3 D1 D6 D.
  exists (s N3). exists leq-s T-size1 N3 D8. split. search. search.
```

## Summary

Avoiding the transport rule is possible, and one can carefully plan out their
proof in order to avoid reproving all lemmas within the library. Subjectively,
the proof becomes more opaque, with repeated invocations of independence lemmas
in every case. The proof which utilizes the transport rule strategically proves
the version in the context, then later proving that it is independent which one
may see as undesirable, but the proofs themselves are clear and involve no
digressions.