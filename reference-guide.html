<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Adelfa: Reference Guide</title>
  <link href="style.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <h1><a href="index.html">Adelfa Home</a></h1>
  <section>
    <center>
      <h1  class="title" id="main">Reference Guide</h1>
    </center>

    <p>
      This document will give a basic introduction to the theorem
      prover and run through a reasoning example demonstrate how it
      can be used to reason about LF specifications.
    </p>
    
  </section>

  <section>
    <h1>Table of Contents</h1>
    <ol>
     <li><a href="#syntax">Syntax</a></li>
     <li><a href="#commands">Top-level Commands</a></li>
     <li><a href="#tactics">Tactics</a></li>
     <li><a href="#lemmas">Lemmas</a></li>
     <li><a href="#typing">Typing</a></li>
     <li><a href="#restrictions">Inductive Restrictions</a></li>
     <li><a href="#emacs">Emacs Support</a></li>
    </ol>
  </section>

  <section>
    <a name="syntax"></a>
    <h1>Syntax</h1>

    <p>The syntax for terms Canonical LF terms and types follows a similar 
       style to that used by Twelf. Of note are the following structures.</p>

    <blockquote>
    <table cellpadding="2">
      <tr><td><code>[x] M</code></td><td><p>(term abstraction)</p></td></tr>
      <tr><td><code>{x:A}B&nbsp;&nbsp;&nbsp;</code></td><td><p>(pi-types)</p></td></tr>
      <tr><td><code>A -> B</code></td><td><p>(shorthand for pi-type without dependency)</p></td></tr>
    </table>
    </blockquote>

    <p>Nominal constants are denoted by <code>n1</code>, <code>n2</code>, ... .
       The names for variables and constants follow the same conventions as Twelf.</p>

    <br>

    <p>Context expressions <code>G</code> are expressed using the following syntax.</p>
    
    <blockquote>
    <table cellpadding="2">
      <tr><td><code>&lt;empty string&gt;&nbsp;&nbsp;&nbsp;</code></td><td><p>(empty context)</p></td></tr>
      <tr><td><code> &Gamma;</code></td><td><p>(context variable)</p></td></tr>
      <tr><td><code> G, n:A</code></td><td><p>(explicit context entry)</p></td></tr>
    </table>
    </blockquote>

    <br>

    <p>The syntax for formulas <code>F</code> is the following.</p>
    
    <blockquote>
    <table cellpadding="2">
      <tr><td><code>forall x y z ..., F</code></td><td><p>(universal quantification)</p></td></tr>
      <tr><td><code>exists x y z ..., F</code></td><td><p>(existential quantification)</p></td></tr>
      <tr><td><code>ctx &Gamma;1:C1 &Gamma;2:C2 ..., F</code></td><td><p>(context quantification)</p></td></tr>
      <tr><td><code>F1 => F2</code></td><td><p>(implication)</p></td></tr>
      <tr><td><code>F1 /\ F2</code></td><td><p>(conjunction)</p></td></tr>
      <tr><td><code>F1 \/ F2</code></td><td><p>(disjunction)</p></td></tr>
      <tr><td><code>{G |- M : A}</code></td><td><p>(atomic formula)</p></td></tr>
      <tr><td><code> pred M1 M2 ...</code></td><td><p>(defined predicate)</p></td></tr>
      <tr><td><code>true</code></td><td><p></p></td></tr>
      <tr><td><code>false</code></td><td><p></p></td></tr>
    </table>
    </blockquote>

    <p>Quantified variables can optionally be given an arity type explicitly 
       which are constructed from <code>o</code> using the constructor <code>-></code>.</p>
  </section>
  
  <section>
    <a name="commands"></a>
    <h1>Top-level commands</h1>
  </section>
  
  <blockquote>
  <table>

    <tr><td>
      <code>Theorem &lt;THM-NAME&gt; : &lt;FORMULA&gt;.</code>
    </td></tr>
    <tr><td>
      <blockquote>
        Puts the prover in proving mode with the given formula as the goal.
      </blockquote>
    </td></tr>
    
    <tr><td>&nbsp;</td></tr>
    
    <tr><td>
      <a name="quit"></a>
        <code>Quit.</code>
    </td></tr>
    <tr><td>
      <blockquote>
        Exits from Adelfa.
      </blockquote>
    </td></tr>

    <tr><td>&nbsp;</td></tr>
    
    <tr><td>
      <a name="specification"></a>
      <code>Specification &lt;QUOTED FILENAME&gt;.</code>
    </td></tr>
    <tr><td>
      <blockquote>
        This command reads in the specification indicated by the given filename.
        <br><br>
        While fully explicit Twelf specifications may be successfully loaded, any
        declaration commands will be ignored.
      </blockquote>
    </td></tr>

    <tr><td>&nbsp;</td></tr>
    
    <tr><td>
      <code>Schema &lt;schema-id&gt :=
              w x ... . y:A,z:B ... ;
              ... .</code>
    </td></tr>
    <tr><td>
      <blockquote>
        This command defines a context schema associated with the identifier 
        <code>&lt;schema-id&gt;</code>.
      </blockquote>
    </td></tr>
    
    <tr><td>&nbsp;</td></tr>

    <tr><td>
      <code>Define &lt;PRED&gt; : &lt;TYPE&gt; by
              &lt;PRED&gt; M1 M2 ... := &lt;FORMULA&gt;;
              &ltPRED&gt; N1 N2 ... := &lt;FORMULA&gt;;
              ... .</code>
    </td></tr>
    <tr><td>
      <blockquote>
        Adds to the prover state a definition of the name <prop-name> defined
        by the given clauses. No nominal constants may appear in a definition,
        and the formula appearing to the left of the := must be an instance of
        the defined predicate. Definitions may only be unfolded or applied to
        an appropriate formula; case analysis cannot be performed on defined
        formulas.
      </blockquote>
    </td></tr>
  </table>
  </blockquote>
  
  <section>
    <a name="tactics"></a>
    <h1>Tactics</h1>
  
    <blockquote>
    <table>
      <tr><td>
        <code>search.</code>
      </tr></td>
      <tr><td>
      <blockquote>
        Search for a derivation of the current goal using matching with
        assumption formulas and decomposing judgments into subgoals using LF
        derivation rules.
      </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>intros.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          Introduces variables and assumptions from a goal formula until it no
          longer has top-level universal quantification, context quantification,
          or implications.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>split.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          If the current goal is a conjunction, <code>F1 /\ F2</code>, creates subgoals for
          each sub formula, <code>F1</code> and <code>F2</code>.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>left.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          If the current goal is a disjunction, <code>F1 \/ F2</code>, changes the goal to be
          the left side formula, <code>F1</code>.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>right.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          If the current goal is a disjunction, <code>F1 \/ F2</code>, changes the goal to be
          the right side formula, <code>F2</code>.
        </blockquote>
      </td></tr>
    
      <tr><td>&nbsp;</td></tr>
    
      <tr><td>
        <code>assert &lt;FORMULA&gt;.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          Changes the proof state to one which has the given formula as a goal;
          once derivation of this goal is complete returns to the previous proof
          state with the given formula added as an assumption.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>apply &lt;HYP NAME&gt; to &lt;HYP NAMES&gt;.</code>
      </tr></td>
      <tr><td>
        <code>apply &lt;HYP NAME&gt; to &lt;HYP NAMES&gt; with (&Gamma;1 = G1), ..., (&Gamma;m = Gm), X1 = M1, ..., Xn = Mn.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          The <code>apply</code> tactic applies a hypothesis of the form
          <code>ctx &Gamma;1:C1 ... &Gamma;j:Cj, forall X1 ... Xi, H1 =&gt; ... =&gt; Hk =&gt; F</code> 
          to argument hypotheses which match <code>H1</code>, ..., <code>Hk</code>. 
          The result is an instantiation
          of <code>F</code>. Either or both of i and j may be zero, that is
          there need not be universally quantified variables or context variables.
          The <code>with</code> clause allows specific instantiations of any of
          the variables <code>X1</code> ... <code>Xi</code> and <code>&Gamma;1</code>
          ... <code>&Gamma;j</code>.

          <br><br>
 
          A previously proved theorem can be used instead of the first 
          hypothesis, and then this acts like using a lemma.
          
          <br><br>
          
          It is recommended to provide the instantiations for quantifiers 
          as the inference of these instantiations is only successful in simple 
          cases.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>induction on &lt;NUM&gt;.</code>
      </td></tr>
      <tr><td>
        <blockquote>
          Given a goal of the form 
          <code>ctx &Gamma;1:C1 &Gamma;2:C2 ..., forall X Y ..., H1 =&gt; H2 =&gt; ... =&gt; F</code> 
          the <code>induction</code> tactic allows you to
          induct on one of <code>H1</code>, <code>H2</code>, <code>...</code>. 
          The hypothesis to be inducted on must be
          an atomic formula. The choice of induction is based on the number
          <code>&lt;NUM&gt;</code>. Applying the <code>induction</code> tactic
          results in an inductive hypothesis being added to the current set of
          hypotheses. Specifics on this inductive hypothesis and how it
          relates to the goal are given in the section <a
          href="#restrictions">Inductive Restrictions</a>.
        
          <br><br>
        
          Adelfa supports nested induction through repeated calls to the
          <code>induction</code> tactic. See the <a
          href="#restrictions">Inductive Restrictions</a> section for
          more details.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>exists M.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          Instantiates an existential goal with the given term, if it is of the
          correct arity type.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>case &lt;HYP NAME&gt;.</code>
      </tr></td>
      <tr><td>
        <code>case &lt;HYP NAME&gt;(keep).</code>
      </tr></td>
      <tr><td>
        <blockquote>
          Performs case analysis on the given assumption formula. By default the
          assumption is removed, use `(keep)' to retain it.
        </blockquote>
      </td></tr>
     
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>weaken &lt;HYP NAME&gt; with A.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          When the given assumption formula is of the form <code>{G |- M : A}</code>, and it can be
          verified that the LF type <code>A</code> must be well formed in the current
          context under <code>G</code>, then a new assumption is added in which the the
          typing judgment is weakened to include the given type.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>strengthen &lt;HYP NAME&gt;.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          If the given assumption formula is of the form <code>{G, n:A1 |- M : A2}</code> if <code>n</code> does not appear
          in <code>M</code> or <code>A2</code> then a new assumption is added in which the typing judgment
          is strengthened to <code>{G |- M : A2}</code>.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>ctxpermute &lt;HYP NAME&gt; to G.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          If the given assumption is of the form <code>{G' |- M:A}</code>, and if the given
          context is a valid permutation of the context <code>G'</code> (i.e. does not violate
          dependencies), then a new assumption is added with the permuted
          context expression <code>G</code>.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>inst &lt;HYP NAME&gt; with n = M.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          If the given assumption formula is of the form <code>{G1,n:B,G2 |- M:A}</code>, 
          and the term <code>M</code> can be determined to be such that 
          <code>{G1 |- M : B}</code>
          is valid then this tactic replaces the given assumption with one in
          which <code>n:B</code> is removed from the context expression and all occurrences of
          <code>n</code> are replaced by <code>M</code>.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>prune &lt;HYP NAME&gt;.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          If the given assumption is of the form <code>{G |- X n1 ... nm : A}</code> 
          for some eigenvariable <code>X</code> and distinct nominal constants 
          <code>n1</code>,<code>...</code>,<code>nm</code> then this
          tactic will prune those nominal constants appearing as arguments to <code>X</code>
          which (1) do not already appear in <code>G</code> and (2) are not permitted in the
          instantiations for the context variable in <code>G</code>.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>

      <tr><td>
        <code>undo.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          Undo the last step of reasoning.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>skip.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          Skip to the next subgoal of the derivation.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>abort.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          Abort the proof construction and return to top-level loop without
          adding formula to the available lemmas.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>unfold.</code>
      </tr></td>
      <tr><td>
        <code> unfold &lt;HYP NAME&gt;.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          If the given assumption formula is a defined predicate then it is
          unfolded using the relevant definition, using the first clause which
          matches. If no assumption formula is given, the goal formula is
          unfolded.
        </blockquote>
      </td></tr>
      
      <tr><td>&nbsp;</td></tr>
      
      <tr><td>
        <code>applydfn &lt;PROP&gt;.</code>
      </tr></td>
      <tr><td>
        <code>applydfn &lt;PROP&gt; to &lt;HYP NAME&gt;.</code>
      </tr></td>
      <tr><td>
        <blockquote>
          Applies a clause of the definition of <code>&lt;PROP&gt;</code> to the
          given assumption formula. The first clause which matches is the one
          used. If no assumption formula is provided the definition is applied
          to the goal formula.
        </blockquote>
      </td></tr>
    </table>
    </blockquote>
  </section>

  <section>
    <a name="lemmas"></a>
    <h1>Lemmas</h1>
    
    <p>
      To use a lemma, prove it as a theorem and then refer to it by name in
      another proof using the <code>apply</code> tactic. For example,
    </p>
    <pre>
    Theorem my_lemma : ...
    ...

    Theorem my_theorem : ...
    ...
    apply my_lemma to H3 H5.
    ...
    </pre>
  </section>

  <section>
    <a name="typing"></a>
    <h1>Typing</h1>
    
    <p>
      Adelfa's logic is simply-typed using simple arity typing based on a single base type
      <code>o</code> and constructor <code>-&gt;</code>. 
      All terms and formulas must be well-typed.
    </p>
  </section>

  <section>
    <a name="restrictions"></a>
    <h1>Inductive Restrictions</h1>
    
    <p>
      Inductive restrictions are represented by <code>*</code> (smaller)
      and <code>@</code> (equal). They are used to track the size of
      inductive arguments rather than using explicit numeric values. For
      example, suppose we apply <code>induction on 1.</code> when trying to
      prove the following subject reduction theorem,
    </p>

    <pre>

    ============================
    forall E V T D1 D2, {|- D1 : eval E V} -> {|- D2: of E T} -> exists D3, {|- D3: of V T}
    </pre>

    <p>We will get the following proof state.</p>

    <pre>
    IH : forall E V T D1 D2, {|- D1 : eval E V}* -> {|- D2: of E T} -> exists D3, {|- D3: of V T}
    ============================
    forall E V T D1 D2, {|- D1 : eval E V}@ -> {|- D2: of E T} -> exists D3, {|- D3: of V T}
    </pre>

    <p>
      Here we have an inductive hypothesis where the inductive argument is
      flagged with <code>*</code>. This means that we can only apply that
      hypothesis to an argument which also has the <code>*</code>.
      Because <code>*</code> means smaller, in order to get an argument with
      a <code>*</code> we must perform case analysis on an argument that is
      "equal" which we denote by <code>@</code>. Thus the above proof
      proceeds by first doing "intros." and then case analysis on 
      <code>{|- D1 : eval E V}@</code>. This will give us two subgoals, 
      one which is trivial and the other which has hypotheses tagged 
      with <code>*</code> and thus eligible for use with the inductive hypothesis.
    </p>
  </section>

  <section>
    <a name="emacs"></a>
    <h1>Emacs Support</h1>
    
    <p>The file <a href="files/adelfa.el">adelfa.el</a> provides an emacs mode for developing proofs. 
       To use, save the file and add the following to your .emacs file.
    </p>
    <pre>(load "/path/to/file/adelfa.el")</pre>

    <p>Where /path/to/file is replaced with the actual location where the file is saved.

       <br><br>

       Note that reading forward commands works properly with the declaring
       specifications and schema definitions, but the moving backwards or
       undoing does not work properly outside of proof development.
    </p>
  </section>
  
</body>
</html>


<!-- LocalWords: adelfa LF Twelf prover IH eval forall subgoal emacs Adelfa's arity el -->
