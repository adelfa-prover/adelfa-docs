{
  "scopeName": "source.adelfa",
  "patterns": [
    {
      "name": "string.quoted.double.adelfa",
      "begin": "\"",
      "end": "\"",
      "patterns": [
        {
          "name": "constant.character.escape.adelfa",
          "match": "\\\\(?:\\r\\n|[\\s\\S])"
        }
      ]
    },
    {
      "name": "constant.language.boolean.adelfa",
      "match": "\\b(?:false|true)\\b"
    },
    {
      "name": "variable.other.adelfa",
      "match": "\\b(?:H[1-9]+[0-9]*|IH[0-9]*)\\b"
    },
    {
      "name": "entity.name.class.adelfa",
      "begin": "(\\b(Theorem|Schema|apply|Subgoal)\\s+)",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.adelfa"
        }
      },
      "end": "?",
      "patterns": [
        {
          "name": "entity.name.class.adelfa",
          "match": "[\\w-'0-9]+"
        }
      ]
    },
    {
      "name": "keyword.operator.adelfa",
      "match": ">>"
    },
    {
      "name": "keyword.other.adelfa",
      "match": "\\b(Theorem|Specification|Set|Schema|Subgoal|Vars)\\b"
    },
    {
      "name": "support.function.adelfa",
      "match": "\\b(apply|forall|exists|case|inst|induction|intros|keep|left|right|search|split|on|to|with|assert|weaken|prune|strengthen|ctxpermute|permute)\\b"
    },
    {
      "name": "keyword.operator.adelfa",
      "match": "(\\\\\\/|\\/\\\\|=>|,|:|=)"
    },
    {
      "name": "constant.numeric.adelfa",
      "match": "\\b([1-9]+[0-9]*)\\b"
    },
    {
      "name": "markup.important.adelfa",
      "match": "\\b(?:skip)\\b|\\."
    },
    {
      "name": "comment.line.percentage.adelfa",
      "begin": "\\s*%",
      "end": "$",
      "patterns": [
        {
          "name": "comment.line.percentage.adelfa",
          "match": ".*"
        }
      ]
    },
    {
      "name": "constant.other.symbol.adelfa",
      "match": "[{}\\[\\]]"
    }
  ]
}
